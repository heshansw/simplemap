{"version":3,"sources":["../src/index.ts","../src/helpers/enum.ts","../src/helpers/utils.ts"],"names":["SortOrder"],"mappings":";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACAO,IAAK,YAAL,kBAAKA,eAAL;AACH,EAAAA,sBAAA,SAAM,KAAN;AACA,EAAAA,sBAAA;AAFQ,SAAAA;AAAA,GAAA;;;ACiBL,IAAM,UACT,CAAI,SACJ,CAAC,QACG,OAAO;AAAA,EACH,OAAO;AAAA,IACH,KAAK;AAAA,MACD,CAAC,IAAI,SAAS,EAAE,GAAG,IAAI,CAAC,GAAG,GAAG,IAAI,GAAG,EAAE;AAAA,MACvC,CAAC;AAAA,IACL;AAAA,EACJ,EAAE,OAAO,CAAC,CAAC,GAAG,KAAK,MAAM,UAAU,MAAS;AAChD;AAUD,IAAM,UACT,CAAI,KAAyB,UAAqB,WAClD,CAAC,SAAsE;AAAA,EACnE,GAAG;AAAA,EACH,CAAC,UAAU,GAAG,GAAG,SAAS,IAAI,GAAG,CAAW;AAChD;AASG,IAAM,UACT,CAAsB,QAAW,aACjC,CAAC,SACI,EAAE,GAAG,KAAK,CAAC,MAAM,GAAG,SAAS,GAAG,EAAE;AASpC,IAAM,WAAW,CACpB,KACA,SACoB,IAAI,IAAI,QAAQ,IAAI,CAAC;AAStC,IAAM,UAAU,CACnB,KACA,QACA,aAEA,IAAI,IAAI,QAAQ,QAAQ,QAAQ,CAAC;AAS9B,IAAM,OAAO,CAChB,KACA,KACA,wBAEA,IAAI;AAAA,EAAK,CAAC,GAAG,OACR,wBAA0B,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,IAAI,EAAE,GAAG,KAAK,IAAI;AACxE;AAEJ,IAAM,cAAc,CAAO,eAAkB,eACxC,kBAAkB,UAAa,gBAAgB,UAAqB,IAC/D,gBAAgB,UAAqB,IACrC;AAQH,IAAM,MAAM,CACf,KACA,SACC,KAAK,MAAM,GAAG,GAAG,OAAO,aAAa,GAAG;AAQtC,IAAM,YAAY,CAIrB,IACA,QAEA,MAAM,OAAO,OAAO,YAAY,OAAO,KAChC,GAAW,GAAG,IACf,OAAO,OAAO,WACZ,OAAO,OAAO,EAAS,EAAE;AAAA,EACrB,CAAC,KAAK,QAAQ,OAAO,UAAU,KAAK,GAAa;AAAA,EACjD;AACJ,IACA","sourcesContent":["import {\n    extract,\n    changeN,\n    changeO,\n    extractA,\n    changeA,\n    sort,\n    get,\n    getKeyVal,\n} from './helpers/utils'\n\nimport { SortOrder } from './helpers/enum'\nimport { OnlyTypes } from './helpers/types'\n\nexport {\n    extract,\n    changeN,\n    changeO,\n    extractA,\n    changeA,\n    sort,\n    get,\n    getKeyVal,\n    OnlyTypes,\n    SortOrder,\n}\n","export enum SortOrder {\n    ASC = 1,\n    DESC,\n}\n","import {\n    NestedKeyOptions,\n    ValueTypeInPath,\n    CallbackN,\n    CallbackO,\n    NumberValueKeys,\n    ReturnCallbackO,\n    NestedKeyTypes,\n} from './types'\nimport { SortOrder } from './enum'\n\n/**\n * Extract key values from an object and create a new object\n * @param keys Keys in an object which needs to be extracted\n * @param obj Original Object\n * @returns Partial Object with extracted key values\n */\nexport const extract =\n    <T>(keys: Array<keyof T>) =>\n    (obj: T): Partial<T> =>\n        Object.fromEntries(\n            Object.entries(\n                keys.reduce(\n                    (ob, key) => ({ ...ob, [key]: obj[key] }),\n                    {} as Partial<T>\n                )\n            ).filter(([_, value]) => value !== undefined)\n        ) as Partial<T>\n\n/**\n * Create new key value (number) inside an existing object from new calculation\n * @param key Key which contains number value\n * @param callback Callback function which will help to calculate new key value\n * @param newKey New key name\n * @param obj Original object\n * @returns Object or extended object\n */\nexport const changeN =\n    <T>(key: NumberValueKeys<T>, callback: CallbackN, newKey?: string) =>\n    (obj: T): T | (T & Record<NumberValueKeys<T>, number>) | undefined => ({\n        ...obj,\n        [newKey ?? key]: callback(obj[key] as number),\n    })\n\n/**\n * Add new manipulated key, value to an existing object\n * @param newKey New key to assign manipulated value\n * @param callback Callback method which can be used for new key value manipulation\n * @param obj Original object\n * @returns Updatted object\n */\nexport const changeO =\n    <T, K extends string>(newKey: K, callback: CallbackO<T>) =>\n    (obj: T): T & Record<K, ReturnCallbackO<T>> =>\n        ({ ...obj, [newKey]: callback(obj) }) as T &\n            Record<K, ReturnCallbackO<T>>\n\n/**\n * Extract specific keys and create new object array\n * @param arr Original Object Array\n * @param keys Keys which needs to be extracted\n * @returns New key extracted object array\n */\nexport const extractA = <T>(\n    arr: Array<T>,\n    keys: Array<keyof T>\n): Array<Partial<T>> => arr.map(extract(keys))\n\n/**\n * Change and add new key value to existing array object\n * @param arr Original Object Array\n * @param newKey New Key\n * @param callback Callback method which can be used for new key value manipulation\n * @returns Altered Object Array\n */\nexport const changeA = <T, K extends string>(\n    arr: Array<T>,\n    newKey: K,\n    callback: CallbackO<T>\n): Array<T & Record<K, ReturnCallbackO<T>>> =>\n    arr.map(changeO(newKey, callback))\n\n/**\n * Sort Arrayt\n * @param arr Original Object Array\n * @param key Sortable Key\n * @param order Optional, Sorting Order\n * @returns Sorted array\n */\nexport const sort = <T>(\n    arr: Array<T>,\n    key: keyof T,\n    order: SortOrder = SortOrder.ASC\n) =>\n    arr.sort((a, b) =>\n        (order === SortOrder.ASC ? a[key] > b[key] : a[key] < b[key]) ? 1 : -1\n    )\n\nconst getKeyValue = <T, P>(currentObject: T, currentKey: P): T =>\n    (currentObject !== undefined && currentObject?.[currentKey as keyof T]\n        ? currentObject?.[currentKey as keyof T]\n        : undefined) as T\n\n/**\n * Get Nested Object key value\n * @param obj Original Object\n * @param path nested key path to value\n * @returns nested path key's value type\n */\nexport const get = <T, P extends NestedKeyOptions<T> & string>(\n    obj: T,\n    path: P\n) => path.split('.')?.reduce(getKeyValue, obj) as ValueTypeInPath<T, P>\n\n/**\n * Get Nested Key Value by giving Object and key\n * @param ob Original Object\n * @param key key which needs to be retrieved\n * @returns found value or undefined\n */\nexport const getKeyVal = <\n    T,\n    K extends (keyof T | keyof NestedKeyTypes<T>) | string,\n>(\n    ob: T,\n    key: K\n): string | number | symbol | object | undefined =>\n    ob && typeof ob === 'object' && key in ob\n        ? (ob as any)[key]\n        : typeof ob === 'object'\n          ? Object.values(ob as any).reduce(\n                (acc, val) => acc || getKeyVal(val, key as string),\n                undefined\n            )\n          : undefined\n"]}